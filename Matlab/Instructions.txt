______________________________________________________________________________
1. Trivia
Author:		Laurens Znidarsic
Version:	2
Last edited:	29-07-2017
Last edited by:	Laurens Znidarsic
_______________________________________________________________________________
2. Function explanation
The scripts in this folder provide a broad toolset to model and analyse 
the test car as provided by the project leader. It is important to understand 
that there are two main functions (Simulation and Analization), a model 
(CarModel), and some supportfunctions (the rest). This short instruction will 
hopefully provide you with just enough knowledge about the functions to be able 
to use and, if neccesary alter them.

2.1 Goal
The goal of this project was to build an easy-to-use test rig with supporting 
software (Model). To build this model, we needed a representive tire model, 
which has yet to be empirically determined. We used the MoCap and some on-board 
sensors to determine this tiremodel (see also our paper). The function 
simulation implements our unfinished (no tire model) CarModel, and uses manual 
user input to visualize the car motion. To create this vizualization, simply 
run the 'simulation'  script. To alter the input, open the CarModel, double-
click the 'input'  block and then double-click the signal builder.

2.2 Simulation function
The simulation function uses some internally defined (nested) functions to 
first convert the car motion to a linspace. It firstly runs the CarModel, and 
then creates a 'Car matrix'  to store all the coordinates of all the points in 
the car drawing. This pre-storing was done because motion calculation during 
plotting resulted in a laggy video. It then uses the function carplot to 
visualize the movement. The function then closes the motion visualization and 
end with a multi-plot of all the car's parameters. These can be used to find 
potential errors.

2.3 Analization Function
The analization function also uses some nested functions to ultimately load 
all sensor data, convert to linspace, calculate missing parameters and store in 
State matrix for further use. The function starts with reading text files 
containing hall sensor sata. These files should be named 'steer#.txt'. Open one 
of these files to understand it's format. Next, the function loads the steering 
data. We manually created these using a simulink model (delta.slx),  but we 
recommend installing a sensor on the test rig for more reliable steering data. 
The steering data files should be named 'delta_Steer#'. After this the function 
loads and processes (1. smoothing, 2. deriving, 3. smoothing, 4. deriving) the 
raw MoCap data. For this it uses a text file with predefined smoothing 
parameters tailored for each test. Use Robert's code and documentation to 
understand how to derive these smoothing parameters.
Finally, the car's equations of motion (see CarModel) are used to reverse-
engineer all the car's motion parameters. All of the parameters are stored in 
the state matrix (S) and saved in a predefined bin. The parameter order can be 
found in the analization script. 
________________________________________________________________________________
3. How to use
It might still be a little bit unclear as to why how these funtions can be used 
to get to a tire model. Here I will try to explain how we saw these functions 
come to good use for this project. 

3.1 Paths
Once you've downloaded the matlab code, the first thing you should do is 
scan the code for file paths, e.g. C:\users\et.c. Replace the paths with the 
paths of the datafiles on your own computer. In this manner, matlab will be 
actually able to find all the files it needs to run the scripts.

3.2 Tire model
As mentioned before, running the analization 
script on (newly gathered) test data, gives you a state matrix with 21 states of 
the motion along the timeline. These states include the kappa and alpha data 
and the Fx and Fy data. Plotting this data in a 3D plot, should give a 
good visual representation of the car's tire model. In our case it didn't, and 
in our report we highlighted several possible causes as to why, and made 
recommendations on how to solve this problem. 
If you succeed in solving this problem, you can implement the tire model into 
your car model in two different ways:
 
1. Storing all the testdata in a matrix and let the model interpolate between 
   test points
2. Finding a representative fit function for your model and let your car model 
   use this fit function

Which of the two would be a better option has yet to be determined, as it fell 
outside of the scope of our research.

3.3 Simulation
If you succeed in finding a representative tire model and manage to implement 
it into your car model, you can manually start testing you model by running the 
simulation with the same input as a field test, and compare the motion of both.
If at some point you see little to no differencee between simulation and real 
data with reasonable repeatability, you can go to the next step.

3.4 Loop closing
At this stage you will attempt to use the car model and simulation to predict 
the car's motion, ultimately closing the MPC loop. 